package es.ull.esit.app.metaheuristics.generators;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import es.ull.esit.app.factory_method.FactoryAcceptCandidate;
import es.ull.esit.app.local_search.acceptation_type.AcceptableCandidate;
import es.ull.esit.app.local_search.candidate_type.CandidateValue;
import es.ull.esit.app.metaheurictics.strategy.Strategy;
import es.ull.esit.app.problem.definition.Problem;
import es.ull.esit.app.problem.definition.State;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedConstruction;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

/**
 * Unit tests for {@link RandomSearch}.
 */
class RandomSearchTest {

    @BeforeEach
    void resetStaticReferences() {
        // Clean static list between tests
        RandomSearch.setListStateReference(new ArrayList<>());

        // Ensure population-based generators are "inactive" by default
        GeneticAlgorithm.setCountRef(0);
        EvolutionStrategies.setCountRef(0);
        DistributionEstimationAlgorithm.setCountRef(0);
        ParticleSwarmOptimization.setCountRef(0);
    }

    /** Helper to set private fields via reflection. */
    private static void setPrivateField(Object target, String fieldName, Object value)
            throws Exception {
        Field f = target.getClass().getDeclaredField(fieldName);
        f.setAccessible(true);
        f.set(target, value);
    }

    /** Helper to create an ArrayList<Double> from varargs. */
    private static ArrayList<Double> eval(double... values) {
        ArrayList<Double> list = new ArrayList<>();
        for (double v : values) {
            list.add(v);
        }
        return list;
    }

    @Test
    void constructorShouldInitializeDefaults() {
        RandomSearch rs = new RandomSearch();

        assertEquals(GeneratorType.RandomSearch, rs.getType());
        assertEquals(GeneratorType.RandomSearch, rs.getTypeGenerator());
        assertEquals(50.0f, rs.getWeight());
        assertNotNull(rs.getTrace());
        assertNotNull(rs.getListCountBetterGender());
        assertNotNull(rs.getListCountGender());
        assertTrue(RandomSearch.getListStateReference().isEmpty());
    }

    @Test
    void generateShouldCallProblemOperatorAndReturnCandidateWithoutStoringWhenNoPopulationAlgorithms()
            throws Exception {

        // Arrange
        RandomSearch rs = new RandomSearch();

        // Mock CandidateValue and inject it into RandomSearch
        CandidateValue candidateValueMock = mock(CandidateValue.class);
        setPrivateField(rs, "candidatevalue", candidateValueMock);

        // Mock Strategy and Problem (deep stubs to avoid Operator import)
        try (MockedStatic<Strategy> strategyStatic = Mockito.mockStatic(Strategy.class)) {
            Strategy strategyMock = mock(Strategy.class, Mockito.RETURNS_DEEP_STUBS);
            strategyStatic.when(Strategy::getStrategy).thenReturn(strategyMock);

            Problem problemMock = strategyMock.getProblem();

            // Neighbourhood generated by operator
            State candidateFromNeighbourhood = new State();
            List<State> neighbourhood = Collections.singletonList(candidateFromNeighbourhood);
            when(problemMock.getOperator().generateRandomState(1)).thenReturn(neighbourhood);

            // CandidateValue chooses this candidate
            State expectedCandidate = new State();
            when(candidateValueMock.stateCandidate(
                    any(), any(), any(), eq(1), eq(neighbourhood)))
                    .thenReturn(expectedCandidate);

            // Ensure no population-based generator is active
            GeneticAlgorithm.setCountRef(0);
            EvolutionStrategies.setCountRef(0);
            DistributionEstimationAlgorithm.setCountRef(0);
            ParticleSwarmOptimization.setCountRef(0);

            // Act & Assert
            State result = assertDoesNotThrow(
                    () -> rs.generate(1),
                    "generate should not throw exceptions"
            );

            assertSame(expectedCandidate, result,
                    "generate should return the candidate returned by CandidateValue");
            assertTrue(RandomSearch.getListStateReference().isEmpty(),
                    "When no population algorithms are active, static listStateReference must remain empty");
        }
    }

    @Test
    void generateShouldStoreCandidateInStaticListWhenPopulationAlgorithmActive()
            throws Exception {

        // Arrange
        RandomSearch rs = new RandomSearch();

        // Mock CandidateValue and inject it
        CandidateValue candidateValueMock = mock(CandidateValue.class);
        setPrivateField(rs, "candidatevalue", candidateValueMock);

        try (MockedStatic<Strategy> strategyStatic = Mockito.mockStatic(Strategy.class)) {
            Strategy strategyMock = mock(Strategy.class, Mockito.RETURNS_DEEP_STUBS);
            strategyStatic.when(Strategy::getStrategy).thenReturn(strategyMock);

            Problem problemMock = strategyMock.getProblem();

            State candidateFromNeighbourhood = new State();
            List<State> neighbourhood = Collections.singletonList(candidateFromNeighbourhood);
            when(problemMock.getOperator().generateRandomState(1)).thenReturn(neighbourhood);

            State expectedCandidate = new State();
            when(candidateValueMock.stateCandidate(
                    any(), any(), any(), eq(1), eq(neighbourhood)))
                    .thenReturn(expectedCandidate);

            // Activate one of the population-based algorithms
            GeneticAlgorithm.setCountRef(1);
            EvolutionStrategies.setCountRef(0);
            DistributionEstimationAlgorithm.setCountRef(0);
            ParticleSwarmOptimization.setCountRef(0);

            // Act
            State result = assertDoesNotThrow(
                    () -> rs.generate(1),
                    "generate should not throw exceptions"
            );

            // Assert
            assertSame(expectedCandidate, result);
            List<State> staticList = RandomSearch.getListStateReference();
            assertEquals(1, staticList.size(),
                    "Static listStateReference should contain one element when population algorithms are active");
            assertSame(expectedCandidate, staticList.get(0));
        }
    }

    @Test
    void updateReferenceShouldSetReferenceWhenCandidateIsBetter()
            throws InvocationTargetException, NoSuchMethodException,
                   InstantiationException, IllegalAccessException,
                   ClassNotFoundException, SecurityException, IllegalArgumentException {

        RandomSearch rs = new RandomSearch();

        State reference = new State();
        reference.setEvaluation(eval(1.0));
        rs.setInitialReference(reference);

        State betterCandidate = new State();
        betterCandidate.setEvaluation(eval(2.0));

        // Mock FactoryAcceptCandidate construction so that no reflection is used
        try (MockedConstruction<FactoryAcceptCandidate> construction =
                     Mockito.mockConstruction(FactoryAcceptCandidate.class,
                             (factoryMock, context) -> {
                                 AcceptableCandidate acceptable = mock(AcceptableCandidate.class);
                                 when(factoryMock.createAcceptCandidate(any()))
                                         .thenReturn(acceptable);
                                 // For this test, we always accept the candidate
                                 when(acceptable.acceptCandidate(reference, betterCandidate))
                                         .thenReturn(true);
                             })) {

            assertDoesNotThrow(
                    () -> rs.updateReference(betterCandidate, 1),
                    "updateReference should not throw"
            );

            assertSame(betterCandidate, rs.getReference(),
                    "Reference state should be updated to the better candidate");
        }
    }

    @Test
    void updateReferenceShouldNotChangeReferenceWhenCandidateIsWorse()
            throws InvocationTargetException, NoSuchMethodException,
                   InstantiationException, IllegalAccessException,
                   ClassNotFoundException, SecurityException, IllegalArgumentException {

        RandomSearch rs = new RandomSearch();

        State reference = new State();
        reference.setEvaluation(eval(2.0));
        rs.setInitialReference(reference);

        State worseCandidate = new State();
        worseCandidate.setEvaluation(eval(1.0));

        try (MockedConstruction<FactoryAcceptCandidate> construction =
                     Mockito.mockConstruction(FactoryAcceptCandidate.class,
                             (factoryMock, context) -> {
                                 AcceptableCandidate acceptable = mock(AcceptableCandidate.class);
                                 when(factoryMock.createAcceptCandidate(any()))
                                         .thenReturn(acceptable);
                                 // For this test, always reject
                                 when(acceptable.acceptCandidate(reference, worseCandidate))
                                         .thenReturn(false);
                             })) {

            assertDoesNotThrow(
                    () -> rs.updateReference(worseCandidate, 1),
                    "updateReference should not throw"
            );

            assertSame(reference, rs.getReference(),
                    "Reference state should remain unchanged when candidate is not accepted");
        }
    }

    @Test
    void getReferenceListShouldIncludeCurrentReference() {
        RandomSearch rs = new RandomSearch();
        State ref = new State();
        rs.setInitialReference(ref);

        List<State> list = rs.getReferenceList();

        assertEquals(1, list.size());
        assertSame(ref, list.get(0));
    }

    @Test
    void awardUpdateREFShouldAlwaysReturnFalse() {
        RandomSearch rs = new RandomSearch();
        State candidate = new State();
        assertFalse(rs.awardUpdateREF(candidate),
                "awardUpdateREF should always return false for RandomSearch");
    }

  @Test
  void generatorTypeGetterAndSetterShouldWork() {
    RandomSearch rs = new RandomSearch();
    
    // Initially both getters should return RandomSearch
    assertEquals(GeneratorType.RandomSearch, rs.getType());
    assertEquals(GeneratorType.RandomSearch, rs.getTypeGenerator());

    // After changing the type, both should reflect the new value
    rs.setTypeGenerator(GeneratorType.MultiobjectiveStochasticHillClimbing);

    assertEquals(GeneratorType.MultiobjectiveStochasticHillClimbing, rs.getTypeGenerator());
    assertEquals(GeneratorType.MultiobjectiveStochasticHillClimbing, rs.getType());
  }

}

